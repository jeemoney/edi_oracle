import { ABIMethod, ABIMethodParams, ABIType, ABIValue, Algodv2, Indexer, SuggestedParams } from 'algosdk';
import { AlgoAmount } from './amount';
import { ABIAppCallArg, ABIAppCallArgs, AppCallArgs, AppLookup, AppMetadata, AppReference, AppState, BoxName, OnSchemaBreak, OnUpdate, RawAppCallArgs, TealTemplateParams } from './app';
import { AppSpec } from './appspec';
import { SendTransactionFrom, SendTransactionParams, TransactionNote } from './transaction';
/** Configuration to resolve app by creator and name @see getCreatorAppsByName */
export type ResolveAppByCreatorAndName = {
    /** The address of the app creator account to resolve the app by */
    creatorAddress: string;
    /** The optional name to resolve the app by within the creator account (default: uses the name in the ABI contract) */
    name?: string;
} & ({
    /** indexer An indexer instance to search the creator account apps */
    indexer: Indexer;
} | {
    /** Optional cached value of the existing apps for the given creator, @see getCreatorAppsByName */
    existingDeployments: AppLookup;
});
/** Configuration to resolve app by ID */
export interface ResolveAppById {
    /** The id of an existing app to call using this client, or 0 if the app hasn't been created yet */
    id: number;
    /** The optional name to use to mark the app when deploying @see ApplicationClient.deploy (default: uses the name in the ABI contract) */
    name?: string;
}
/** The details of an ARC-0032 app spec specified app */
export type AppSpecAppDetails = {
    /** The ARC-0032 application spec as either:
     *  * Parsed JSON @see {AppSpec}
     *  * Raw JSON string
     */
    app: AppSpec | string;
    /** Default sender to use for transactions issued by this application client */
    sender?: SendTransactionFrom;
    /** Default suggested params object to use */
    params?: SuggestedParams;
} & (ResolveAppById | ResolveAppByCreatorAndName);
/** Parameters to pass into ApplicationClient.deploy */
export interface AppClientDeployParams {
    /** The version of the contract, uses "1.0" by default */
    version?: string;
    /** The optional sender to send the transaction from, will use the application client's default sender by default if specified */
    sender?: SendTransactionFrom;
    /** Whether or not to allow updates in the contract using the deploy-time updatability control if present in your contract.
     * If this is not specified then it will automatically be determined based on the AppSpec definition
     **/
    allowUpdate?: boolean;
    /** Whether or not to allow deletes in the contract using the deploy-time deletability control if present in your contract.
     * If this is not specified then it will automatically be determined based on the AppSpec definition
     **/
    allowDelete?: boolean;
    /** Parameters to control transaction sending */
    sendParams?: Omit<SendTransactionParams, 'skipSending' | 'skipWaiting'>;
    /** Any deploy-time parameters to replace in the TEAL code */
    deployTimeParams?: TealTemplateParams;
    /** What action to perform if a schema break is detected */
    onSchemaBreak?: 'replace' | 'fail' | OnSchemaBreak;
    /** What action to perform if a TEAL update is detected */
    onUpdate?: 'update' | 'replace' | 'fail' | OnUpdate;
    /** Any args to pass to any create transaction that is issued as part of deployment */
    createArgs?: AppClientCallArgs;
    /** Any args to pass to any update transaction that is issued as part of deployment */
    updateArgs?: AppClientCallArgs;
    /** Any args to pass to any delete transaction that is issued as part of deployment */
    deleteArgs?: AppClientCallArgs;
}
/** The arguments to pass to an Application Client smart contract call */
export type AppClientCallArgs = {
    /** Raw argument values to pass to the smart contract call */
    args?: RawAppCallArgs;
} | {
    /** If calling an ABI method then either the name of the method, or the ABI signature */
    method: string;
    /** Either the ABI arguments or an object with the ABI arguments and other parameters like boxes */
    methodArgs: Omit<ABIAppCallArgs, 'method'> | ABIAppCallArg[];
};
/** Parameters to construct a ApplicationClient contract call */
export type AppClientCallParams = AppClientCallArgs & {
    /** The optional sender to send the transaction from, will use the application client's default sender by default if specified */
    sender?: SendTransactionFrom;
    /** The transaction note for the smart contract call */
    note?: TransactionNote;
    /** Parameters to control transaction sending */
    sendParams?: SendTransactionParams;
};
/** Parameters for creating a contract using ApplicationClient */
export type AppClientCreateParams = AppClientCallParams & {
    /** Any deploy-time parameters to replace in the TEAL code */
    deployTimeParams?: TealTemplateParams;
    updatable?: boolean;
    deletable?: boolean;
};
/** Parameters for updating a contract using ApplicationClient */
export type AppClientUpdateParams = AppClientCreateParams;
/** Parameters for funding an app account */
export interface FundAppAccountParams {
    amount: AlgoAmount;
    /** The optional sender to send the transaction from, will use the application client's default sender by default if specified */
    sender?: SendTransactionFrom;
    /** The transaction note for the smart contract call */
    note?: TransactionNote;
    /** Parameters to control transaction sending */
    sendParams?: SendTransactionParams;
}
/** Application client - a class that wraps an ARC-0032 app spec and provides high productivity methods to deploy and call the app */
export declare class ApplicationClient {
    private algod;
    private indexer?;
    private appSpec;
    private sender;
    private params;
    private existingDeployments;
    private _appId;
    private _appAddress;
    private _creator;
    private _appName;
    private _approvalSourceMap;
    private _clearSourceMap;
    /**
     * Create a new ApplicationClient instance
     * @param appDetails The details of the app
     * @param algod An algod instance
     * @param indexer An indexer instance
     */
    constructor(appDetails: AppSpecAppDetails, algod: Algodv2);
    /**
     * Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator account, including deploy-time template placeholder substitutions.
     *
     * To understand the architecture decisions behind this functionality please @see https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md
     *
     * **Note:** if there is a breaking state schema change to an existing app (and `onSchemaBreak` is set to `'replace'`) the existing app will be deleted and re-created.
     *
     * **Note:** if there is an update (different TEAL code) to an existing app (and `onUpdate` is set to `'replace'`) the existing app will be deleted and re-created.
     * @param deploy Deployment details
     * @returns The metadata and transaction result(s) of the deployment, or just the metadata if it didn't need to issue transactions
     */
    deploy(deploy?: AppClientDeployParams): Promise<(Partial<import("./app").AppCompilationResult> & import("./transaction").ConfirmedTransactionResult & AppMetadata & {
        operationPerformed: "update" | "create";
    }) | (Partial<import("./app").AppCompilationResult> & import("./transaction").ConfirmedTransactionResult & AppMetadata & {
        deleteResult: import("./transaction").ConfirmedTransactionResult;
        operationPerformed: "replace";
    }) | (Partial<import("./app").AppCompilationResult> & AppMetadata & {
        operationPerformed: "nothing";
    })>;
    create(create?: AppClientCreateParams): Promise<Partial<import("./app").AppCompilationResult> & import("./app").AppCallTransactionResult & AppReference>;
    update(update?: AppClientUpdateParams): Promise<Partial<import("./app").AppCompilationResult> & import("./app").AppCallTransactionResult>;
    call(call: AppClientCallParams): Promise<import("./app").AppCallTransactionResult>;
    optIn(call: AppClientCallParams): Promise<import("./app").AppCallTransactionResult>;
    closeOut(call: AppClientCallParams): Promise<import("./app").AppCallTransactionResult>;
    clearState(call: AppClientCallParams): Promise<import("./app").AppCallTransactionResult>;
    delete(call: AppClientCallParams): Promise<import("./app").AppCallTransactionResult>;
    private _call;
    /**
     * Funds ALGOs into the app account for this app.
     * @param fund The parameters for the funding or the funding amount
     * @returns The result of the funding
     */
    fundAppAccount(fund: FundAppAccountParams | AlgoAmount): Promise<import("./transaction").SendTransactionResult>;
    /**
     * Returns global state for the current app.
     * @returns The global state
     */
    getGlobalState(): Promise<AppState>;
    /**
     * Returns local state for the given account / account address.
     * @returns The global state
     */
    getLocalState(account: string | SendTransactionFrom): Promise<AppState>;
    /**
     * Returns the names of all current boxes for the current app.
     * @returns The names of the boxes
     */
    getBoxNames(): Promise<BoxName[]>;
    /**
     * Returns the values of all current boxes for the current app.
     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.
     * @param filter Optional filter to filter which boxes' values are returned
     * @returns The (name, value) pair of the boxes with values as raw byte arrays
     */
    getBoxValues(filter?: (name: BoxName) => boolean): Promise<{
        name: BoxName;
        value: Uint8Array;
    }[]>;
    /**
     * Returns the values of all current boxes for the current app decoded using an ABI Type.
     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.
     * @param type The ABI type to decode the values with
     * @param filter Optional filter to filter which boxes' values are returned
     * @returns The (name, value) pair of the boxes with values as the ABI Value
     */
    getBoxValuesAsABIType(type: ABIType, filter?: (name: BoxName) => boolean): Promise<{
        name: BoxName;
        value: ABIValue;
    }[]>;
    /**
     * Returns the arguments for an app call for the given ABI method or raw method specification.
     * @param args The call args specific to this application client
     * @returns The call args ready to pass into an app call
     */
    getCallArgs(args?: AppClientCallArgs): AppCallArgs | undefined;
    /**
     * Returns the ABI Method parameters for the given method name string for the app represented by this application client instance
     * @param method Either the name of the method or the ABI method spec definition string
     * @returns The ABI method params for the given method
     */
    getABIMethodParams(method: string): ABIMethodParams | undefined;
    /**
     * Returns the ABI Method for the given method name string for the app represented by this application client instance
     * @param method Either the name of the method or the ABI method spec definition string
     * @returns The ABI method for the given method
     */
    getABIMethod(method: string): ABIMethod | undefined;
    /**
     * Gets the reference information for the current application instance.
     * `appId` will be 0 if it can't find an app.
     * @returns The app reference, or if deployed using the `deploy` method, the app metadata too
     */
    getAppReference(): Promise<AppMetadata | AppReference>;
    /**
     * Takes an error that may include a logic error from a smart contract call and re-exposes the error to include source code information via the source map.
     * This is automatically used within @see ApplicationClient but if you pass `skipSending: true` e.g. if doing a group transaction
     *  then you can use this in a try/catch block to get better debugging information.
     * @param e The error to parse
     * @param isClear Whether or not the code was running the clear state program
     * @returns The new error, or if there was no logic error or source map then the wrapped error with source details
     */
    exposeLogicError(e: Error, isClear?: boolean): Error;
}
//# sourceMappingURL=application-client.d.ts.map