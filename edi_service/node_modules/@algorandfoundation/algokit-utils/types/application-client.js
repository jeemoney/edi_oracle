"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationClient = void 0;
const algosdk_1 = __importStar(require("algosdk"));
const buffer_1 = require("buffer");
const app_1 = require("../app");
const deploy_app_1 = require("../deploy-app");
const transaction_1 = require("../transaction");
const transfer_1 = require("../transfer");
const app_2 = require("./app");
const appspec_1 = require("./appspec");
const logic_error_1 = require("./logic-error");
/** Application client - a class that wraps an ARC-0032 app spec and provides high productivity methods to deploy and call the app */
class ApplicationClient {
    // todo: process ABI args as needed to make them nicer to deal with like beaker-ts
    // todo: support importing and exporting a source map
    // todo: support readonly, noop method calls
    // todo: support different oncomplete for create
    // todo: find create, update, delete, etc. methods from app spec and call them by default
    // todo: intelligent version management when deploying
    /**
     * Create a new ApplicationClient instance
     * @param appDetails The details of the app
     * @param algod An algod instance
     * @param indexer An indexer instance
     */
    constructor(appDetails, algod) {
        const { app, sender, params, ...appIdentifier } = appDetails;
        this.algod = algod;
        this.appSpec = typeof app == 'string' ? JSON.parse(app) : app;
        this._appName = appIdentifier.name ?? this.appSpec.contract.name;
        if ('creatorAddress' in appIdentifier) {
            this._appId = 0;
            this._creator = appIdentifier.creatorAddress;
            if ('indexer' in appIdentifier) {
                this.indexer = appIdentifier.indexer;
            }
            else {
                if (appIdentifier.existingDeployments.creator !== this._creator) {
                    throw new Error(`Attempt to create application client with invalid existingDeployments against a different creator (${appIdentifier.existingDeployments.creator}) instead of expected creator ${this._creator}`);
                }
                this.existingDeployments = appIdentifier.existingDeployments;
            }
        }
        else {
            if (appIdentifier.id < 0) {
                throw new Error(`Attempt to create application client with invalid app id of ${appIdentifier.id}`);
            }
            this._appId = appIdentifier.id;
        }
        this._appAddress = algosdk_1.default.getApplicationAddress(this._appId);
        this.sender = sender;
        this.params = params;
    }
    /**
     * Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator account, including deploy-time template placeholder substitutions.
     *
     * To understand the architecture decisions behind this functionality please @see https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md
     *
     * **Note:** if there is a breaking state schema change to an existing app (and `onSchemaBreak` is set to `'replace'`) the existing app will be deleted and re-created.
     *
     * **Note:** if there is an update (different TEAL code) to an existing app (and `onUpdate` is set to `'replace'`) the existing app will be deleted and re-created.
     * @param deploy Deployment details
     * @returns The metadata and transaction result(s) of the deployment, or just the metadata if it didn't need to issue transactions
     */
    async deploy(deploy) {
        const { sender, version, allowUpdate, allowDelete, sendParams, createArgs, updateArgs, deleteArgs, ...deployArgs } = deploy ?? {};
        if (this._appId !== 0) {
            throw new Error(`Attempt to deploy app which already has an app id of ${this._appId}`);
        }
        if (!sender && !this.sender) {
            throw new Error('No sender provided, unable to deploy app');
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const from = sender ?? this.sender;
        if (!this._creator) {
            throw new Error('Attempt to deploy a contract without having specified a creator');
        }
        if (this._creator !== (0, transaction_1.getSenderAddress)(from)) {
            throw new Error(`Attempt to deploy contract with a sender address (${(0, transaction_1.getSenderAddress)(from)}) that differs from the given creator address for this application client: ${this._creator}`);
        }
        const approval = buffer_1.Buffer.from(this.appSpec.source.approval, 'base64').toString('utf-8');
        const clear = buffer_1.Buffer.from(this.appSpec.source.clear, 'base64').toString('utf-8');
        try {
            await this.getAppReference();
            const result = await (0, deploy_app_1.deployApp)({
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                from,
                approvalProgram: approval,
                clearStateProgram: clear,
                metadata: {
                    name: this._appName,
                    version: version ?? '1.0',
                    updatable: allowUpdate ?? approval.includes(app_2.UPDATABLE_TEMPLATE_NAME)
                        ? (!this.appSpec.bare_call_config.update_application && this.appSpec.bare_call_config.update_application !== 'NEVER') ||
                            !!Object.keys(this.appSpec.hints).filter((h) => !this.appSpec.hints[h].call_config.update_application &&
                                this.appSpec.hints[h].call_config.update_application !== 'NEVER')[0]
                        : undefined,
                    deletable: allowDelete ?? approval.includes(app_2.DELETABLE_TEMPLATE_NAME)
                        ? (!this.appSpec.bare_call_config.delete_application && this.appSpec.bare_call_config.delete_application !== 'NEVER') ||
                            !!Object.keys(this.appSpec.hints).filter((h) => !this.appSpec.hints[h].call_config.delete_application &&
                                this.appSpec.hints[h].call_config.delete_application !== 'NEVER')[0]
                        : undefined,
                },
                schema: {
                    globalByteSlices: this.appSpec.state.global.num_byte_slices,
                    globalInts: this.appSpec.state.global.num_uints,
                    localByteSlices: this.appSpec.state.local.num_byte_slices,
                    localInts: this.appSpec.state.local.num_uints,
                },
                transactionParams: this.params,
                ...(sendParams ?? {}),
                existingDeployments: this.existingDeployments,
                createArgs: this.getCallArgs(createArgs),
                updateArgs: this.getCallArgs(updateArgs),
                deleteArgs: this.getCallArgs(deleteArgs),
                ...deployArgs,
            }, this.algod, this.indexer);
            this._approvalSourceMap = result.compiledApproval?.sourceMap;
            this._clearSourceMap = result.compiledClear?.sourceMap;
            // Nothing needed to happen
            if (result.operationPerformed === 'nothing') {
                return result;
            }
            if (!this.existingDeployments) {
                throw new Error('Expected existingDeployments to be present');
            }
            const { transaction, confirmation, operationPerformed, ...appMetadata } = result;
            this.existingDeployments = {
                creator: this.existingDeployments.creator,
                apps: { ...this.existingDeployments.apps, [this._appName]: appMetadata },
            };
            return result;
        }
        catch (e) {
            throw this.exposeLogicError(e);
        }
    }
    async create(create) {
        const { sender, note, sendParams, deployTimeParams, updatable, deletable, ...args } = create ?? {};
        if (this._appId !== 0) {
            throw new Error(`Attempt to create app which already has an app id of ${this._appId}`);
        }
        if (!sender && !this.sender) {
            throw new Error('No sender provided, unable to create app');
        }
        const approval = buffer_1.Buffer.from(this.appSpec.source.approval, 'base64').toString('utf-8');
        const clear = buffer_1.Buffer.from(this.appSpec.source.clear, 'base64').toString('utf-8');
        try {
            const result = await (0, app_1.createApp)({
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                from: sender ?? this.sender,
                approvalProgram: (0, deploy_app_1.replaceDeployTimeControlParams)((0, deploy_app_1.performTemplateSubstitution)(approval, deployTimeParams), {
                    updatable,
                    deletable,
                }),
                clearStateProgram: (0, deploy_app_1.performTemplateSubstitution)(clear, deployTimeParams),
                schema: {
                    globalByteSlices: this.appSpec.state.global.num_byte_slices,
                    globalInts: this.appSpec.state.global.num_uints,
                    localByteSlices: this.appSpec.state.local.num_byte_slices,
                    localInts: this.appSpec.state.local.num_uints,
                },
                args: this.getCallArgs(args),
                note: note,
                transactionParams: this.params,
                ...(sendParams ?? {}),
            }, this.algod);
            this._approvalSourceMap = result.compiledApproval?.sourceMap;
            this._clearSourceMap = result.compiledClear?.sourceMap;
            if (result.confirmation) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this._appId = result.confirmation['application-index'];
                this._appAddress = (0, algosdk_1.getApplicationAddress)(this._appId);
            }
            return result;
        }
        catch (e) {
            throw this.exposeLogicError(e);
        }
    }
    async update(update) {
        const { sender, note, sendParams, deployTimeParams, updatable, deletable, ...args } = update ?? {};
        if (this._appId === 0) {
            throw new Error(`Attempt to update app which doesn't have an app id defined`);
        }
        if (!sender && !this.sender) {
            throw new Error('No sender provided, unable to create app');
        }
        const approval = buffer_1.Buffer.from(this.appSpec.source.approval, 'base64').toString('utf-8');
        const clear = buffer_1.Buffer.from(this.appSpec.source.clear, 'base64').toString('utf-8');
        try {
            const result = await (0, app_1.updateApp)({
                appId: this._appId,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                from: sender ?? this.sender,
                approvalProgram: (0, deploy_app_1.replaceDeployTimeControlParams)((0, deploy_app_1.performTemplateSubstitution)(approval, deployTimeParams), {
                    updatable,
                    deletable,
                }),
                clearStateProgram: (0, deploy_app_1.performTemplateSubstitution)(clear, deployTimeParams),
                args: this.getCallArgs(args),
                note: note,
                transactionParams: this.params,
                ...(sendParams ?? {}),
            }, this.algod);
            this._approvalSourceMap = result.compiledApproval?.sourceMap;
            this._clearSourceMap = result.compiledClear?.sourceMap;
            return result;
        }
        catch (e) {
            throw this.exposeLogicError(e);
        }
    }
    async call(call) {
        return await this._call(call, 'normal');
    }
    async optIn(call) {
        return await this._call(call, 'optin');
    }
    async closeOut(call) {
        return await this._call(call, 'optin');
    }
    async clearState(call) {
        return await this._call(call, 'optin');
    }
    async delete(call) {
        return await this._call(call, 'optin');
    }
    async _call(call, callType) {
        const { sender, note, sendParams, ...args } = call;
        if (!sender && !this.sender) {
            throw new Error('No sender provided, unable to call app');
        }
        const appMetadata = await this.getAppReference();
        if (appMetadata.appId === 0) {
            throw new Error(`Attempt to call an app that can't be found '${this._appName}' for creator '${this._creator}'.`);
        }
        try {
            return await (0, app_1.callApp)({
                appId: appMetadata.appId,
                callType: callType,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                from: sender ?? this.sender,
                args: this.getCallArgs(args),
                note: note,
                transactionParams: this.params,
                ...(sendParams ?? {}),
            }, this.algod);
        }
        catch (e) {
            throw this.exposeLogicError(e);
        }
    }
    /**
     * Funds ALGOs into the app account for this app.
     * @param fund The parameters for the funding or the funding amount
     * @returns The result of the funding
     */
    async fundAppAccount(fund) {
        const { amount, sender, note, sendParams } = 'microAlgos' in fund ? { amount: fund } : fund;
        if (!sender && !this.sender) {
            throw new Error('No sender provided, unable to call app');
        }
        const ref = await this.getAppReference();
        return await (0, transfer_1.transferAlgos)({
            to: ref.appAddress,
            amount: amount,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            from: this.sender ?? sender,
            note: note,
            transactionParams: this.params,
            ...(sendParams ?? {}),
        }, this.algod);
    }
    /**
     * Returns global state for the current app.
     * @returns The global state
     */
    async getGlobalState() {
        const appRef = await this.getAppReference();
        if (appRef.appId === 0) {
            throw new Error('No app has been created yet, unable to get global state');
        }
        return (0, app_1.getAppGlobalState)(appRef.appId, this.algod);
    }
    /**
     * Returns local state for the given account / account address.
     * @returns The global state
     */
    async getLocalState(account) {
        const appRef = await this.getAppReference();
        if (appRef.appId === 0) {
            throw new Error('No app has been created yet, unable to get global state');
        }
        return (0, app_1.getAppLocalState)(appRef.appId, account, this.algod);
    }
    /**
     * Returns the names of all current boxes for the current app.
     * @returns The names of the boxes
     */
    async getBoxNames() {
        const appRef = await this.getAppReference();
        if (appRef.appId === 0) {
            throw new Error('No app has been created yet, unable to get global state');
        }
        return await (0, app_1.getAppBoxNames)(appRef.appId, this.algod);
    }
    /**
     * Returns the values of all current boxes for the current app.
     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.
     * @param filter Optional filter to filter which boxes' values are returned
     * @returns The (name, value) pair of the boxes with values as raw byte arrays
     */
    async getBoxValues(filter) {
        const appRef = await this.getAppReference();
        if (appRef.appId === 0) {
            throw new Error('No app has been created yet, unable to get global state');
        }
        const names = await this.getBoxNames();
        return await Promise.all(names
            .filter(filter ?? ((_) => true))
            .map(async (boxName) => ({ name: boxName, value: await (0, app_1.getAppBoxValue)(appRef.appId, boxName, this.algod) })));
    }
    /**
     * Returns the values of all current boxes for the current app decoded using an ABI Type.
     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.
     * @param type The ABI type to decode the values with
     * @param filter Optional filter to filter which boxes' values are returned
     * @returns The (name, value) pair of the boxes with values as the ABI Value
     */
    async getBoxValuesAsABIType(type, filter) {
        const appRef = await this.getAppReference();
        if (appRef.appId === 0) {
            throw new Error('No app has been created yet, unable to get global state');
        }
        const names = await this.getBoxNames();
        return await Promise.all(names.filter(filter ?? ((_) => true)).map(async (boxName) => ({
            name: boxName,
            value: await (0, app_1.getAppBoxValueFromABIType)({ appId: appRef.appId, boxName, type }, this.algod),
        })));
    }
    /**
     * Returns the arguments for an app call for the given ABI method or raw method specification.
     * @param args The call args specific to this application client
     * @returns The call args ready to pass into an app call
     */
    getCallArgs(args) {
        if (!args) {
            return undefined;
        }
        if ('method' in args) {
            const abiMethod = this.getABIMethodParams(args.method);
            if (!abiMethod) {
                throw new Error(`Attempt to call ABI method ${args.method}, but it wasn't found`);
            }
            if (Array.isArray(args.methodArgs)) {
                return {
                    method: abiMethod,
                    args: args.methodArgs,
                };
            }
            else {
                return {
                    method: abiMethod,
                    ...args.methodArgs,
                };
            }
        }
        else {
            return args.args;
        }
    }
    /**
     * Returns the ABI Method parameters for the given method name string for the app represented by this application client instance
     * @param method Either the name of the method or the ABI method spec definition string
     * @returns The ABI method params for the given method
     */
    getABIMethodParams(method) {
        if (!method.includes('(')) {
            const methods = this.appSpec.contract.methods.filter((m) => m.name === method);
            if (methods.length > 1) {
                throw new Error(`Received a call to method ${method} in contract ${this._appName}, but this resolved to multiple methods; please pass in an ABI signature instead: ${methods.map(appspec_1.getABISignature).join(', ')}`);
            }
            return methods[0];
        }
        return this.appSpec.contract.methods.find((m) => (0, appspec_1.getABISignature)(m) === method);
    }
    /**
     * Returns the ABI Method for the given method name string for the app represented by this application client instance
     * @param method Either the name of the method or the ABI method spec definition string
     * @returns The ABI method for the given method
     */
    getABIMethod(method) {
        const methodParams = this.getABIMethodParams(method);
        return methodParams ? new algosdk_1.ABIMethod(methodParams) : undefined;
    }
    /**
     * Gets the reference information for the current application instance.
     * `appId` will be 0 if it can't find an app.
     * @returns The app reference, or if deployed using the `deploy` method, the app metadata too
     */
    async getAppReference() {
        if (!this.existingDeployments && this._creator) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.existingDeployments = await (0, deploy_app_1.getCreatorAppsByName)(this._creator, this.indexer);
        }
        if (this.existingDeployments && this._appId === 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const app = this.existingDeployments.apps[this._appName];
            if (!app) {
                return {
                    appId: 0,
                    appAddress: (0, algosdk_1.getApplicationAddress)(0),
                };
            }
            return app;
        }
        return {
            appId: this._appId,
            appAddress: this._appAddress,
        };
    }
    /**
     * Takes an error that may include a logic error from a smart contract call and re-exposes the error to include source code information via the source map.
     * This is automatically used within @see ApplicationClient but if you pass `skipSending: true` e.g. if doing a group transaction
     *  then you can use this in a try/catch block to get better debugging information.
     * @param e The error to parse
     * @param isClear Whether or not the code was running the clear state program
     * @returns The new error, or if there was no logic error or source map then the wrapped error with source details
     */
    exposeLogicError(e, isClear) {
        if ((!isClear && this._approvalSourceMap == undefined) || (isClear && this._clearSourceMap == undefined))
            return e;
        const errorDetails = logic_error_1.LogicError.parseLogicError(e.message);
        if (errorDetails !== undefined)
            return new logic_error_1.LogicError(errorDetails, buffer_1.Buffer.from(isClear ? this.appSpec.source.clear : this.appSpec.source.approval, 'base64')
                .toString()
                .split('\n'), 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            isClear ? this._clearSourceMap : this._approvalSourceMap);
        else
            return e;
    }
}
exports.ApplicationClient = ApplicationClient;
//# sourceMappingURL=application-client.js.map