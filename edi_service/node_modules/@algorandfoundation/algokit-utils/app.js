"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileTeal = exports.getAppByIndex = exports.getAppArgsForTransaction = exports.decodeAppState = exports.getAppBoxValuesFromABIType = exports.getAppBoxValueFromABIType = exports.getAppBoxValues = exports.getAppBoxValue = exports.getAppBoxNames = exports.getAppLocalState = exports.getAppGlobalState = exports.getABIReturn = exports.callApp = exports.updateApp = exports.createApp = void 0;
const algosdk_1 = __importStar(require("algosdk"));
const buffer_1 = require("buffer");
const _1 = require("./");
const transaction_1 = require("./transaction");
const app_1 = require("./types/app");
/**
 * Creates a smart contract app, returns the details of the created app.
 * @param create The parameters to create the app with
 * @param algod An algod client
 * @returns The details of the created app, or the transaction to create it if `skipSending`
 */
async function createApp(create, algod) {
    const { from, approvalProgram: approval, clearStateProgram: clear, schema, note, transactionParams, args, ...sendParams } = create;
    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;
    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;
    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;
    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;
    const transaction = algosdk_1.default.makeApplicationCreateTxnFromObject({
        approvalProgram: approvalProgram,
        clearProgram: clearProgram,
        numLocalInts: schema.localInts,
        numLocalByteSlices: schema.localByteSlices,
        numGlobalInts: schema.globalInts,
        numGlobalByteSlices: schema.globalByteSlices,
        extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / app_1.APP_PAGE_MAX_SIZE),
        onComplete: algosdk_1.default.OnApplicationComplete.NoOpOC,
        suggestedParams: await (0, transaction_1.getTransactionParams)(transactionParams, algod),
        from: (0, transaction_1.getSenderAddress)(from),
        note: (0, transaction_1.encodeTransactionNote)(note),
        ...getAppArgsForTransaction(args),
        rekeyTo: undefined,
    });
    const { confirmation } = await (0, transaction_1.sendTransaction)({ transaction, from, sendParams }, algod);
    if (confirmation) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const appId = confirmation['application-index'];
        _1.Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${(0, transaction_1.getSenderAddress)(from)}`);
        return {
            transaction,
            confirmation,
            appId,
            appAddress: algosdk_1.default.getApplicationAddress(appId),
            return: getABIReturn(args, confirmation),
            compiledApproval,
            compiledClear,
        };
    }
    else {
        return { transaction, appId: 0, appAddress: '', compiledApproval, compiledClear };
    }
}
exports.createApp = createApp;
/**
 * Updates a smart contract app.
 * @param update The parameters to update the app with
 * @param algod An algod client
 * @returns The transaction
 */
async function updateApp(update, algod) {
    const { appId, from, approvalProgram: approval, clearStateProgram: clear, note, transactionParams, args, ...sendParams } = update;
    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;
    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;
    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;
    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;
    const transaction = algosdk_1.default.makeApplicationUpdateTxnFromObject({
        appIndex: appId,
        approvalProgram: approvalProgram,
        clearProgram: clearProgram,
        suggestedParams: await (0, transaction_1.getTransactionParams)(transactionParams, algod),
        from: (0, transaction_1.getSenderAddress)(from),
        note: (0, transaction_1.encodeTransactionNote)(note),
        ...getAppArgsForTransaction(args),
        rekeyTo: undefined,
    });
    _1.Config.getLogger(sendParams.suppressLog).debug(`Updating app ${appId}`);
    const result = await (0, transaction_1.sendTransaction)({ transaction, from, sendParams }, algod);
    return {
        ...result,
        return: getABIReturn(args, result.confirmation),
        compiledApproval,
        compiledClear,
    };
}
exports.updateApp = updateApp;
/**
 * Issues a call to a given app.
 * @param call The call details.
 * @param algod An algod client
 * @returns The result of the call
 */
async function callApp(call, algod) {
    const { appId, callType, from, args, note, transactionParams, ...sendParams } = call;
    const appCallParams = {
        appIndex: appId,
        from: (0, transaction_1.getSenderAddress)(from),
        suggestedParams: await (0, transaction_1.getTransactionParams)(transactionParams, algod),
        ...getAppArgsForTransaction(args),
        note: (0, transaction_1.encodeTransactionNote)(note),
        rekeyTo: undefined,
    };
    let transaction;
    switch (callType) {
        case 'optin':
            transaction = algosdk_1.default.makeApplicationOptInTxnFromObject(appCallParams);
            break;
        case 'clearstate':
            transaction = algosdk_1.default.makeApplicationClearStateTxnFromObject(appCallParams);
            break;
        case 'closeout':
            transaction = algosdk_1.default.makeApplicationCloseOutTxnFromObject(appCallParams);
            break;
        case 'delete':
            transaction = algosdk_1.default.makeApplicationDeleteTxnFromObject(appCallParams);
            break;
        case 'normal':
            transaction = algosdk_1.default.makeApplicationNoOpTxnFromObject(appCallParams);
            break;
    }
    const result = await (0, transaction_1.sendTransaction)({ transaction, from, sendParams }, algod);
    return {
        ...result,
        return: getABIReturn(args, result.confirmation),
    };
}
exports.callApp = callApp;
function getABIReturn(args, confirmation) {
    try {
        if (!args || !('method' in args)) {
            return undefined;
        }
        const method = 'txnCount' in args.method ? args.method : new algosdk_1.ABIMethod(args.method);
        if (method.returns.type !== 'void' && confirmation) {
            const logs = confirmation.logs || [];
            if (logs.length === 0) {
                throw new Error('App call transaction did not log a return value');
            }
            const lastLog = logs[logs.length - 1];
            if (lastLog.byteLength < 4 || lastLog.slice(0, 4).toString() !== app_1.ABI_RETURN_PREFIX.toString()) {
                throw new Error('App call transaction did not log a return value (ABI_RETURN_PREFIX not found)');
            }
            return {
                rawReturnValue: new Uint8Array(lastLog.slice(4)),
                returnValue: method.returns.type.decode(new Uint8Array(lastLog.slice(4))),
                decodeError: undefined,
            };
        }
    }
    catch (e) {
        return {
            rawReturnValue: undefined,
            returnValue: undefined,
            decodeError: e,
        };
    }
    return undefined;
}
exports.getABIReturn = getABIReturn;
/**
 * Returns the current global state values for the given app ID
 * @param appId The ID of the app return global state for
 * @param algod An algod client instance
 * @returns The current global state
 */
async function getAppGlobalState(appId, algod) {
    const appInfo = await getAppByIndex(appId, algod);
    if (!appInfo.params || !appInfo.params['global-state']) {
        throw new Error("Couldn't find global state");
    }
    return decodeAppState(appInfo.params['global-state']);
}
exports.getAppGlobalState = getAppGlobalState;
/**
 * Returns the current global state values for the given app ID and account
 * @param appId The ID of the app return global state for
 * @param account Either the string address of an account or an account object for the account to get local state for the given app
 * @param algod An algod client instance
 * @returns The current local state for the given (app, account) combination
 */
async function getAppLocalState(appId, account, algod) {
    const accountAddress = typeof account === 'string' ? account : (0, transaction_1.getSenderAddress)(account);
    const appInfo = await algod.accountApplicationInformation(accountAddress, appId).do();
    if (!appInfo['app-local-state'] || !appInfo['app-local-state']['key-value']) {
        throw new Error("Couldn't find local state");
    }
    return decodeAppState(appInfo['app-local-state']['key-value']);
}
exports.getAppLocalState = getAppLocalState;
/**
 * Returns the names of the boxes for the given app.
 * @param appId The ID of the app return box names for
 * @param algod An algod client instance
 * @returns The current box names
 */
async function getAppBoxNames(appId, algod) {
    const boxResult = await algod.getApplicationBoxes(appId).do();
    return boxResult.boxes.map((b) => {
        return {
            nameRaw: b.name,
            nameBase64: buffer_1.Buffer.from(b.name).toString('base64'),
            name: buffer_1.Buffer.from(b.name).toString('utf-8'),
        };
    });
}
exports.getAppBoxNames = getAppBoxNames;
/**
 * Returns the value of the given box name for the given app.
 * @param appId The ID of the app return box names for
 * @param boxName The name of the box to return either as a string, binary array or @see BoxName
 * @param algod An algod client instance
 * @returns The current box value as a byte array
 */
async function getAppBoxValue(appId, boxName, algod) {
    const name = typeof boxName === 'string' ? new Uint8Array(buffer_1.Buffer.from(boxName, 'utf-8')) : 'name' in boxName ? boxName.nameRaw : boxName;
    const boxResult = await algod.getApplicationBoxByName(appId, name).do();
    return boxResult.value;
}
exports.getAppBoxValue = getAppBoxValue;
/**
 * Returns the value of the given box names for the given app.
 * @param appId The ID of the app return box names for
 * @param boxNames The names of the boxes to return either as a string, binary array or @see BoxName
 * @param algod An algod client instance
 * @returns The current box values as a byte array in the same order as the passed in box names
 */
async function getAppBoxValues(appId, boxNames, algod) {
    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValue(appId, boxName, algod)));
}
exports.getAppBoxValues = getAppBoxValues;
/**
 * Returns the value of the given box name for the given app decoded based on the given ABI type.
 * @param request The parameters for the box value request
 * @param algod An algod client instance
 * @returns The current box value as an ABI value
 */
async function getAppBoxValueFromABIType(request, algod) {
    const { appId, boxName, type } = request;
    const value = await getAppBoxValue(appId, boxName, algod);
    return type.decode(value);
}
exports.getAppBoxValueFromABIType = getAppBoxValueFromABIType;
/**
 * Returns the value of the given box names for the given app decoded based on the given ABI type.
 * @param request The parameters for the box value request
 * @param algod An algod client instance
 * @returns The current box values as an ABI value in the same order as the passed in box names
 */
async function getAppBoxValuesFromABIType(request, algod) {
    const { appId, boxNames, type } = request;
    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValueFromABIType({ appId, boxName, type }, algod)));
}
exports.getAppBoxValuesFromABIType = getAppBoxValuesFromABIType;
// Converts an array of global-state or global-state-deltas to a more
// friendly generic object
function decodeAppState(state) {
    const stateValues = {};
    // Start with empty set
    for (const stateVal of state) {
        const keyBase64 = stateVal.key;
        const keyRaw = buffer_1.Buffer.from(keyBase64, 'base64');
        const key = keyRaw.toString('utf-8');
        const tealValue = stateVal.value;
        const dataTypeFlag = 'action' in tealValue ? tealValue.action : tealValue.type;
        let valueBase64;
        let valueRaw;
        switch (dataTypeFlag) {
            case 1:
                valueBase64 = 'bytes' in tealValue ? tealValue.bytes : '';
                valueRaw = buffer_1.Buffer.from(valueBase64, 'base64');
                stateValues[key] = {
                    keyRaw,
                    keyBase64,
                    valueRaw: new Uint8Array(valueRaw),
                    valueBase64: valueBase64,
                    value: valueRaw.toString('utf-8'),
                };
                break;
            case 2:
                // eslint-disable-next-line no-case-declarations
                const value = 'uint' in tealValue ? tealValue.uint : 0;
                stateValues[key] = {
                    keyRaw,
                    keyBase64,
                    value,
                };
                break;
            default:
                throw new Error(`Received unknown state data type of ${dataTypeFlag}`);
        }
    }
    return stateValues;
}
exports.decodeAppState = decodeAppState;
/** Returns the app args ready to load onto an app @see {Transaction} object */
function getAppArgsForTransaction(args) {
    if (!args)
        return undefined;
    let actualArgs;
    if ('method' in args) {
        // todo: Land a change to algosdk that extracts the logic from ATC, because (fair warning) this is a HACK
        // I don't want to have to rewrite all of the ABI resolution logic so using an ATC temporarily here
        // and passing stuff in to keep it happy like a randomly generated account :O
        // Most of these values aren't being used since the transaction is discarded
        const dummyAtc = new algosdk_1.AtomicTransactionComposer();
        const dummyAccount = algosdk_1.default.generateAccount();
        const dummySigner = (0, algosdk_1.makeBasicAccountTransactionSigner)(dummyAccount);
        const dummyAppId = 1;
        const dummyParams = {
            fee: 1,
            firstRound: 1,
            genesisHash: buffer_1.Buffer.from('abcd', 'utf-8').toString('base64'),
            genesisID: 'a',
            lastRound: 1,
        };
        const methodArgs = args.args?.map((a) => {
            if (typeof a !== 'object') {
                return a;
            }
            // Handle the various forms of transactions to wrangle them for ATC
            return 'txn' in a
                ? a
                : 'transaction' in a
                    ? { txn: a.transaction, signer: dummySigner }
                    : 'txID' in a
                        ? { txn: a, signer: dummySigner }
                        : a;
        });
        const dummyOnComplete = algosdk_1.OnApplicationComplete.NoOpOC;
        dummyAtc.addMethodCall({
            method: 'txnCount' in args.method ? args.method : new algosdk_1.ABIMethod(args.method),
            methodArgs,
            // Rest are dummy values
            appID: dummyAppId,
            sender: dummyAccount.addr,
            signer: dummySigner,
            suggestedParams: dummyParams,
            onComplete: dummyOnComplete,
        });
        const txns = dummyAtc.buildGroup();
        const txn = txns[txns.length - 1];
        actualArgs = {
            accounts: txn.txn.appAccounts,
            appArgs: txn.txn.appArgs,
            apps: txn.txn.appForeignApps,
            assets: txn.txn.appForeignAssets,
            boxes: args.boxes?.map((b) => (typeof b === 'object' && 'appId' in b ? b : { appId: 0, name: b })),
            lease: args.lease,
        };
    }
    else {
        actualArgs = args;
    }
    const encoder = new TextEncoder();
    return {
        accounts: actualArgs?.accounts?.map((a) => (typeof a === 'string' ? a : algosdk_1.default.encodeAddress(a.publicKey))),
        appArgs: actualArgs?.appArgs?.map((a) => (typeof a === 'string' ? encoder.encode(a) : a)),
        boxes: actualArgs?.boxes
            ?.map((b) => (typeof b === 'object' && 'appId' in b ? b : { appId: 0, name: b }))
            ?.map((ref) => ({
            appIndex: ref.appId,
            name: typeof ref.name === 'string' ? encoder.encode(ref.name) : ref.name,
        })),
        foreignApps: actualArgs?.apps,
        foreignAssets: actualArgs?.assets,
        lease: typeof actualArgs?.lease === 'string' ? encoder.encode(actualArgs?.lease) : actualArgs?.lease,
    };
}
exports.getAppArgsForTransaction = getAppArgsForTransaction;
/**
 * Gets the current data for the given app from algod.
 *
 * @param appId The id of the app
 * @param algod An algod client
 * @returns The data about the app
 */
async function getAppByIndex(appId, algod) {
    return (await algod.getApplicationByID(appId).do());
}
exports.getAppByIndex = getAppByIndex;
/**
 * Compiles the given TEAL using algod and returns the result.
 *
 * @param algod An algod client
 * @param tealCode The TEAL code
 * @returns The information about the compiled file
 */
async function compileTeal(tealCode, algod) {
    const compiled = await algod.compile(tealCode).sourcemap(true).do();
    return {
        teal: tealCode,
        compiled: compiled.result,
        compiledHash: compiled.hash,
        compiledBase64ToBytes: new Uint8Array(buffer_1.Buffer.from(compiled.result, 'base64')),
        sourceMap: new algosdk_1.SourceMap(compiled['sourcemap']),
    };
}
exports.compileTeal = compileTeal;
//# sourceMappingURL=app.js.map